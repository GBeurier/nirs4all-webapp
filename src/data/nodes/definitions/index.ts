/**
 * Node Definitions Master Index
 *
 * Central export point for all node definitions across all categories.
 * This module aggregates nodes from all subdirectories and provides
 * utility functions for accessing nodes by type, category, or ID.
 */

// Import all node definition groups
import preprocessingNodes from './preprocessing';
import splittingNodes from './splitting';
import modelNodes from './models';
import yProcessingNodes from './y-processing';
import generatorNodes from './generators';
import branchingNodes from './branching';
import filterNodes from './filters';
import augmentationNodes from './augmentation';
import containerNodes from './containers';
import miscNodes from './misc';

// Canonical registry (auto-generated by scripts/generate_registry.py)
import canonicalRegistryData from '../generated/canonical-registry.json';

import type { NodeDefinition, NodeType } from '../types';

// ============================================================================
// All Nodes Combined
// ============================================================================

/**
 * Complete list of all node definitions (curated)
 */
export const allNodes: NodeDefinition[] = [
  ...preprocessingNodes,
  ...splittingNodes,
  ...modelNodes,
  ...yProcessingNodes,
  ...generatorNodes,
  ...branchingNodes,
  ...filterNodes,
  ...augmentationNodes,
  ...containerNodes,
  ...miscNodes,
];

// ============================================================================
// Node Access Utilities
// ============================================================================

/**
 * Get a node by its unique ID
 */
export function getNodeById(id: string): NodeDefinition | undefined {
  return allNodes.find(node => node.id === id);
}

/**
 * Get a node by its name (case-insensitive)
 */
export function getNodeByName(name: string): NodeDefinition | undefined {
  const lowerName = name.toLowerCase();
  return allNodes.find(node => node.name.toLowerCase() === lowerName);
}

/**
 * Get a node by its classPath
 */
export function getNodeByClassPath(classPath: string): NodeDefinition | undefined {
  return allNodes.find(node =>
    node.classPath === classPath ||
    node.legacyClassPaths?.includes(classPath)
  );
}

/**
 * Get all nodes of a specific type
 */
export function getNodesByType(type: NodeType): NodeDefinition[] {
  return allNodes.filter(node => node.type === type);
}

/**
 * Get all nodes matching a category
 */
export function getNodesByCategory(category: string): NodeDefinition[] {
  return allNodes.filter(node => node.category === category);
}

/**
 * Get all nodes from a specific source (sklearn, nirs4all, etc.)
 */
export function getNodesBySource(source: string): NodeDefinition[] {
  return allNodes.filter(node => node.source === source);
}

/**
 * Get all nodes matching any of the given tags
 */
export function getNodesByTags(tags: string[]): NodeDefinition[] {
  const tagSet = new Set(tags.map(t => t.toLowerCase()));
  return allNodes.filter(node =>
    node.tags?.some(t => tagSet.has(t.toLowerCase()))
  );
}

/**
 * Search nodes by name, description, or tags
 */
export function searchNodes(query: string): NodeDefinition[] {
  const lowerQuery = query.toLowerCase();
  return allNodes.filter(node =>
    node.name.toLowerCase().includes(lowerQuery) ||
    node.description.toLowerCase().includes(lowerQuery) ||
    node.tags?.some(t => t.toLowerCase().includes(lowerQuery))
  );
}

/**
 * Get all deep learning models
 */
export function getDeepLearningNodes(): NodeDefinition[] {
  return allNodes.filter(node => node.isDeepLearning === true);
}

/**
 * Get all container nodes
 */
export function getContainerNodes(): NodeDefinition[] {
  return allNodes.filter(node => node.isContainer === true);
}

/**
 * Get all generator nodes
 */
export function getGeneratorNodes(): NodeDefinition[] {
  return allNodes.filter(node => node.isGenerator === true);
}

// ============================================================================
// Grouped Exports
// ============================================================================

/**
 * Nodes organized by type (8 consolidated types)
 */
export const nodesByType: Record<NodeType, NodeDefinition[]> = {
  preprocessing: preprocessingNodes,
  splitting: splittingNodes,
  model: modelNodes,
  y_processing: yProcessingNodes,
  filter: filterNodes,
  augmentation: augmentationNodes,
  flow: [...branchingNodes, ...containerNodes],
  utility: [...generatorNodes, ...miscNodes],
};

// ============================================================================
// Re-exports
// ============================================================================

export {
  preprocessingNodes,
  splittingNodes,
  modelNodes,
  yProcessingNodes,
  generatorNodes,
  branchingNodes,
  filterNodes,
  augmentationNodes,
  containerNodes,
  miscNodes,
};

// Re-export types
export type { NodeDefinition, NodeType } from '../types';

// ============================================================================
// Canonical Registry Integration
// ============================================================================

/**
 * All nodes from the auto-generated canonical registry.
 * Produced by: python scripts/generate_registry.py
 *
 * The canonical registry auto-discovers ALL operators from nirs4all and
 * sklearn, with metadata from _webapp_meta class attributes and UI overlays.
 */
export const canonicalNodes: NodeDefinition[] = canonicalRegistryData as NodeDefinition[];

/**
 * Merge curated definitions with the canonical registry.
 *
 * Curated definitions take priority for nodes that exist in both sources.
 * Canonical-only nodes (e.g., sklearn operators without curated definitions)
 * are appended after the curated ones.
 *
 * This function is intended for gradual migration from curated -> canonical.
 */
export function getAllNodesWithCanonical(): NodeDefinition[] {
  const curatedIds = new Set(allNodes.map(n => n.id));
  const extraNodes = canonicalNodes.filter(n => !curatedIds.has(n.id));
  return [...allNodes, ...extraNodes];
}
